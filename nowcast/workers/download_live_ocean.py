#  Copyright 2013-2020 The Salish Sea MEOPAR contributors
#  and The University of British Columbia
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""SalishSeaCast worker that downloads a daily averaged file from the
University of Washington Live Ocean model forecast product for a specified date.
The file contains a hyperslab that covers the Salish Sea NEMO model western
(Juan de Fuca) open boundary that is generated by UW running our
salishsea_tools.UBC_subdomain module.
"""
import logging
import math
import multiprocessing
import os
import tempfile
from pathlib import Path

import arrow
import nemo_cmd.api
from dateutil import tz
from nemo_nowcast import NowcastWorker, WorkerError
from retrying import retry, RetryError

from nowcast import lib, ssh_sftp

NAME = "download_live_ocean"
logger = logging.getLogger(NAME)


def main():
    """Set up and run the worker.

    For command-line usage see:

    :command:`python -m nowcast.workers.download_live_ocean -h`
    """
    worker = NowcastWorker(NAME, description=__doc__)
    worker.init_cli()
    worker.cli.add_date_option(
        "--run-date",
        default=arrow.now().floor("day"),
        help="Date to download the Live Ocean forecast product for.",
    )
    worker.run(download_live_ocean, success, failure)
    return worker


def success(parsed_args):
    ymd = parsed_args.run_date.format("YYYY-MM-DD")
    logger.info(f"{ymd} Live Ocean file for Salish Sea western boundary downloaded")
    msg_type = "success"
    return msg_type


def failure(parsed_args):
    ymd = parsed_args.run_date.format("YYYY-MM-DD")
    logger.critical(
        f"{ymd} Live Ocean file for Salish Sea western boundary download failed"
    )
    msg_type = "failure"
    return msg_type


def download_live_ocean(parsed_args, config, *args):
    yyyymmdd = parsed_args.run_date.format("YYYYMMDD")
    dotted_yyyymmdd = parsed_args.run_date.format("YYYY.MM.DD")
    ymd = parsed_args.run_date.format("YYYY-MM-DD")
    logger.info(
        f"downloading Salish Sea western boundary daily averaged Live Ocean "
        f"file for {ymd}"
    )
    host_name = config["temperature salinity"]["download"]["host"]
    ssh_key = Path(
        os.environ["HOME"],
        ".ssh",
        config["temperature salinity"]["download"]["ssh key"],
    )
    try:
        ssh_client, sftp_client = ssh_sftp.sftp(host_name, ssh_key)
        process_status_tmpl = config["temperature salinity"]["download"][
            "status file template"
        ]
        process_status_path = Path(process_status_tmpl.format(yyyymmdd=dotted_yyyymmdd))
        try:
            _is_file_ready(sftp_client, host_name, process_status_path)
        except RetryError as exc:
            logger.error(
                f"giving up after {exc.last_attempt.attempt_number} attempts: "
                f"{exc.last_attempt.value[1]} for {process_status_path}"
            )
            raise WorkerError
        bc_file_tmpl = config["temperature salinity"]["download"]["bc file template"]
        bc_file_path = Path(bc_file_tmpl.format(yyyymmdd=dotted_yyyymmdd))
        dest_dir = Path(
            config["temperature salinity"]["download"]["dest dir"], yyyymmdd
        )
        filename = config["temperature salinity"]["download"]["file name"]
        grp_name = config["file group"]
        lib.mkdir(dest_dir, logger, grp_name=grp_name)
        sftp_client.get(os.fspath(bc_file_path), dest_dir / filename)
        logger.debug(f"downloaded {host_name}:{bc_file_path} to {dest_dir/filename}")
    finally:
        sftp_client.close()
        ssh_client.close()
    nemo_cmd.api.deflate(
        [dest_dir / filename], math.floor(multiprocessing.cpu_count() / 2)
    )
    checklist = {ymd: os.fspath(dest_dir / filename)}
    return checklist


def _retry_if_not_ready(ready):
    return not ready


@retry(
    retry_on_result=_retry_if_not_ready,
    wait_fixed=5 * 60 * 1000,
    stop_max_delay=3 * 3600 * 1000,
    wrap_exception=True,
)
def _is_file_ready(sftp_client, host_name, process_status_path):
    end_time, status = None, None
    with tempfile.NamedTemporaryFile("wt") as process_status:
        sftp_client.get(os.fspath(process_status_path), process_status.name)
        logger.debug(f"downloaded {host_name}:{process_status_path}")
        for line in open(process_status.name, "rt"):
            if line.startswith("end_time"):
                end_time = arrow.get(line.split(",")[1].strip())
                end_time = arrow.get(end_time.datetime, tz.gettz("US/Pacific"))
            if line.startswith("result"):
                status = line.split(",")[1].strip()
        if status == "success" and end_time < arrow.now(tz.gettz("US/Pacific")):
            logger.debug(
                f"LiveOcean low_passed_UBC.nc file generation completed at {end_time}"
            )
            return True
        else:
            logger.debug(
                "LiveOcean low_passed_UBC.nc file processing not completed yet"
            )
            return False


if __name__ == "__main__":
    main()  # pragma: no cover
